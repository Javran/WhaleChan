{-# LANGUAGE
    LambdaCase
  , TypeApplications
  , NamedFieldPuns
  , ScopedTypeVariables
  , DataKinds
  , OverloadedStrings
  #-}
module Javran.WhaleChan.TimerThread
 ( timerThread
 ) where

import Control.Concurrent (threadDelay)
import Control.Concurrent.Chan
import Control.Monad
import Control.Monad.State
import Control.Monad.Writer
import Data.Maybe
import Data.Proxy
import Data.Time.Clock
import Data.Time.Format
import Data.Time.LocalTime
import Data.Time.LocalTime.TimeZone.Olson
import Data.Time.LocalTime.TimeZone.Series
import Data.Typeable
import Say

import qualified Data.Map.Strict as M
import qualified Data.Text as T

import Javran.WhaleChan.Types
import Javran.WhaleChan.Base
import Javran.WhaleChan.ReminderSupply
import Javran.WhaleChan.Util

{-
  reminder impl draft:

  - concepts:

    + a EventReminder contains a sorted list of pending reminders
      around a particular event.
    + several type implements ReminderSupply, which, when called with
      current time generates a corresponding EventReminder.
      (NOTE: this is a pure function, we'll worry about parsing maintenance times later)
    + these types are promoted data types, unified by a common kind: ReminderSupplier

- we'll have a list of reminders implemented, visible to
  the reminder thread

- the timer thread keeps track of a Map from TypeRep of ReminderSupplier
  to EventReminder

- when EventReminder cannot be found or contains an empty list of eventReminderDues,
  timer thread will attempt to "resupply" by calling corresponding reminder.

- we'll basically reminder the following events:

    + "30 mins before [some event]"
    + "10 mins before [some event]"
    + "5 mins before [some event]"
    + "[some event] is happening"

  but this is by no meaning a limit, the definition of ReminderSupply
  is flexible to allow time much more longer - for example

- the reminder thread is a loop that:

  + wakes up at (roughly) the beginning of every minute
  + then determine if it's time to remind something
  + send the post to telegram thread
  + after this is done, we'll try to "resupply" EventReminder that are empty
  + for dealing with maintenance times, we'll have a dummy ReminderSupplier
    that does nothing upon resupply - a dedicated thread will check and parse
    maintenance time on a regular basis and supply timer thread with result,
    instead of doing passive "resupply"

- TODO we current have the problem that when one reminder coincide with
  another one generated by the same event reminder, the latter gets one minute delay.
  this is because we only renew after messages are processed, we'll need some thoughts
  to get this processed properly.

- However, this is not a big deal though, as short-term reminder suppliers
  like "practice refresh" or "daily quest reset" are not supposed
  to have reminders that are "12 hours before" and other longer events
  like weekly or quarterly won't have this overlapping problem.

- Draft of a possible fix:
  change State type to Map TypeRep [EventReminder]
  in which EventReminders are sorted and have unique eventOccurTime

  + now that ReminderSupply will be used everytime we wake up to see if we can
    an additional EventReminder is needed (obviuosly if we end up with same eventOccurTime
    we should not do anything to the existing EventReminder)

 -}

oneSec :: Int
oneSec = 1000000

oneMin :: Int
oneMin = oneSec * 60

{-
  wait and wake up at (roughly) begining of the next minute
  -- https://stackoverflow.com/a/8578237/315302
 -}
waitUntilStartOfNextMinute :: IO ()
waitUntilStartOfNextMinute = do
    t <- getCurrentTime
    -- compute millseconds since beginning of current minute
    let ms = round (fromIntegral oneSec * realToFrac @_ @Double (utctDayTime t)) `rem` oneMin
    -- wait to start of next minute
    threadDelay $ oneMin - ms
    -- TODO: we only wait for 5s now for it's easier to debug
    -- threadDelay (oneSec * 5)

reminderSupplies :: [EReminderSupply]
reminderSupplies =
    [ ERS (Proxy :: Proxy 'PracticeReset)
    , ERS (Proxy :: Proxy 'DailyQuestReset)
    , ERS (Proxy :: Proxy 'WeeklyQuestReset)
    , ERS (Proxy :: Proxy 'MonthlyQuestReset)
    , ERS (Proxy :: Proxy 'QuarterlyQuestReset)
    , ERS (Proxy :: Proxy 'ExtraOperationReset)
    , ERS (Proxy :: Proxy 'SenkaAccounting)
    , ERS (Proxy :: Proxy 'QuestPointDeadline)
    ]

type TimerM = StateT (M.Map TypeRep EventReminder) IO

timerThread :: Chan TgRxMsg -> TimerM ()
timerThread tgMsgChan = do
    tzPt <- liftIO $ getTimeZoneSeriesFromOlsonFile "/usr/share/zoneinfo/US/Pacific"
    tzs <- liftIO $ getTimeZoneSeriesFromOlsonFile "/usr/share/zoneinfo/Asia/Tokyo"
    -- TODO: in future we'll need to persistent the thread state
    -- INVARIANT: all values of the State Map shouldn't
    -- contain EventReminder whose eventReminderDues is empty

    -- note: cleaning-up here might not be a good idea as
    -- it might lead to some reminder times being discharged without being
    -- considered
    let restockReminders = do
          -- re-stock EventReminder here
          -- we've been careful to make sure EventReminder whose erds is empty
          -- is removed instead of being kept. which means we just need to restock those
          -- that returns Nothing by lookup
          tDone <- liftIO getCurrentTime
          let restock (ERS tp) = Endo (M.alter altVal tyRep)
                where
                  tyRep = typeRep tp
                  altVal x = case x of
                    Nothing -> Just (renewSupply tp tzs tDone)
                    Just _ -> x
          modify (appEndo (foldMap restock reminderSupplies))
    restockReminders
    -- into infinite loop
    forever $ do
      -- wait until the start of next minute
      t' <- liftIO (waitUntilStartOfNextMinute >> getCurrentTime)
      let timeRep = formatTime defaultTimeLocale (iso8601DateFormat $ Just "%H:%M:%S%Q") t'
          -- any event in future within 20 seconds is also included
          -- this assume that we can always process all reminders within 20 seconds
          -- which should be way more than enough.
          tThres = addUTCTime 20 t'
      liftIO $ sayString $ "Woke up at " ++ timeRep
      -- scan & update reminders, and collect things needed to be displayed
      displayList <- (catMaybes <$>) . forM reminderSupplies $ \e@(ERS tp) ->
        let tyRep = typeRep tp
        in gets (M.lookup tyRep) >>= \case
            Nothing -> pure Nothing
            Just (EventReminder eot erds) -> do
              -- if remindsDue contains anything, we should send current reminder
              let (remindsDue, erds') = span (< tThres) erds
                  newVal = if null erds'
                    then Nothing
                    else Just (EventReminder eot erds')
              modify (M.update (const newVal) tyRep)
              pure $ if null remindsDue
                then Nothing
                else Just (e, eot)
      -- process display, IO is sufficient
      liftIO $ forM_ displayList $ \(ERS tp, eTime) -> do
        let tyRep = typeRep tp
        sayString $ "Reminder: " <> show tyRep
        let lt = utcToLocalTime' tzs eTime
            lt' = utcToLocalTime' tzPt eTime
        -- round to closest second, this would hopefully
        -- give us xxx minutes 0 seconds instead of some 59 seconds
        -- well, technically we are right by taking the floor
        -- as we are processing it at this second but sounds
        -- unhappy to always have some 59 seconds around
        let timeStr = describeDuration (round (eTime `diffUTCTime` t') :: Int)
        sayString $ "  Remaining time: " <> timeStr
        sayString $ "  Japan:   " <> show (localDay lt) <> " " <> show (localTimeOfDay lt)
        sayString $ "  Pacific: " <> show (localDay lt') <> " " <> show (localTimeOfDay lt')
        let tgMsg = "Reminder: " <> T.pack (show tyRep) <> " Remaining time: " <> T.pack timeStr
        writeChan tgMsgChan (TgRMTimer tgMsg)
      -- re-stock EventReminder here
      restockReminders

-- TODO: use lens-datetime

type EventReminders = M.Map TypeRep [EventReminder]

type ReminderM = WCM EventReminders

{-
-- tricky to do in TypeRep?
reminderThread :: WEnv -> IO ()
reminderThread wenv = do
    autoWCM @EventReminders "Reminder" "reminder.yaml" wenv $ \_markStart -> do
      pure ()
 -}
